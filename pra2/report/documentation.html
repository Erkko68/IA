<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IA: Load Curves</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 60px;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Simple Header Container */
        .header {
            color: black;
            text-align: left; /* Center the title */
            margin-top: 30px; /* Add vertical padding */
            margin-bottom: -30px;
        }

        /* Title Styling */
        .header .title {
            font-size: 2.5em;
            font-weight: bold;
        }

        /* Button class */
        .button {
            padding: 15px 25px;
            font-size: 18px;
            cursor: pointer;
            background-color: #2342dd;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
            text-align: center;
            margin: 5px;
            display: inline-block; /* Allow width to adjust based on content */
        }


        .button:hover {
            background-color: #152a96;
        }

        .button.selected {
            background-color: #101f69;
        }

        /* Button container for vertical or horizontal layout */
        .button-container {
            display: flex;
            gap: 10px;
            flex-wrap: wrap; /* Allows wrapping for horizontal layout */
        }

        /* Layout for vertical buttons */
        .vertical {
            flex-direction: column;
            align-items: center;
        }

        /* Layout for horizontal buttons */
        .horizontal {
            flex-direction: row;
            justify-content: center;
        }

        .container {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            gap: 10px; /* Space between columns */
        }

        .column {
            flex: 1;
            display: flex;
            flex-direction: column; 
            box-sizing: border-box;
        }

        /* Optional: If you want zero spacing between containers */
        .container + .container {
            margin-top: 0;  /* Removes the extra margin specifically between consecutive containers */
        }

        /* Slider below images */
        .slider-container {
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
        }

        /* New wrapper for slider and labels */
        .slider-wrapper {
            position: relative;
            max-width: 600px;
            margin: 0 auto;
        }

        /* Slider itself */
        #imageSlider, #pcaSlider {
            width: 100%;
        }

        /* Container for the labels */
        .slider-labels {
            display: flex;
            justify-content: space-between;
            position: absolute;
            bottom: -30px;
            width: 100%;
            text-align: center;
        }

        /* Separator line across the screen */
        .separator {
            width: 100%;
            height: 1px;
            background-color: #ddd;
        }

        .content-text {
            border-radius: 5px;
            margin: 30px 30px;
            font-size: 18px;
            text-align: justify;
        }

    </style>
</head>
<body>

    <div class="header">
        <div class="title">Clustering: Common Daily Load Curves</div>
    </div>
    <div class="container">
        <div class="column"> 
            <div class="content-text">
                <p>En aquestat apartat s'analitzaran el conjunt de dades per identificar els patrons de consum elèctric. Després de carregar les dades de consum i convertirles al dataframe de polars, per tal de garantir un anàlisi precis en el temps, convertint els registres de temps a la zona horària local ("Europa/Madrid") i extraient els atributs corresponents de <code>hora</code> i <code>data</code>. Aquesta informació temporal és essencial per identificar patrons diaris, que són fonamentals per a les tècniques de clustering basades en comportaments temporals.</p>
                <p>A continuació, les dades es classifiquen per <code>codi_postal</code> i <code>localtime</code> per facilitar les operacions de sèrie temporal i el càlcul de mètriques agregades. Es calculen estadístiques mòbils, incloent-hi la mitjana mòbil de 48 hores, la desviació estàndard i el 10è percentil en una finestra de 168 hores. Aquestes estadístiques ofereixen una perspectiva sobre les tendències locals de consum i ajuden a identificar variacions anòmales en el consum que podrien influir en la creació de clústers.</p>
                <p>Les mètriques calculades s’integren al conjunt de dades original i es normalitzen utilitzant valors Z (Z-normalització), cosa que permet que els valors de consum es comparin de manera uniforme independentment de les diferències de magnitud entre codis postals, aquest aspecte é smolt important a l'hora de realitzar clustering amb la tècnica de K-means ja que aquest es veu molt influenciat per dades anòmales amb valors molt grans o molt petits. Es filtren els valors anòmals eliminant els registres amb consum zero (ja que no aporten informació rellevan) i aplicant llindars de normalització Z i quantils mòbils per eliminar soroll i destacar patrons significatius.</p>        
            </div>
        </div>
        <div class="column"> 
            <div class="content-text">
                <p>Seguidament, les dades es preparen per al clustering agregant percentatges de consum en finestres de tres hores, normalitzades segons el consum diari. Aquesta transformació ajuda a capturar patrons intradia, que són crucials per diferenciar comportaments entre regions o dies. El conjunt de dades es transforma a un format ampli (wide format), que organitza els percentatges de consum per hores com a columnes, i es desa com un fitxer Parquet per aplicar-se a altres algoritmes. Aquest format facilita la introducció de les dades en algoritmes de clustering, proporcionant una representació clara de les tendències horàries i regionals.</p>
                <p>Finalment, hem de tenir en compte les implicacions que té treballar amb cada model. En el model K-means, els outliners afecten molt al agrupament de dades i disposar de massa de dimensions poden afectar al afegir soroll innecessari per al model, per aquest motiu apliquem una reducció de dimensionalitat (PCA). De forma similar podem utilitzar el PCA per al model hierarchical clustering i així obtenir divisions del conjunt de dades més precises</p>
                <p>En les visualitzacions següents es mostren 5 tipus d'escalat de dades per cada model de clustering, cada escalat s'ha probat amb un rang de 2 a 7 clusters i aplicant una reducció de dimensionalitat (PCA) de 2 a 5. Seleccionant els botons de la esquerra i movent el slider es pot ajustar la visualització de cada iteració de clustering. Les tres primeres imatges (de esquerra a dreta) coresponen al K-means i mostren la curva identificada, la visualització t-SNE i el coeficient de silueta, a sota d'aquestes tres imatges trobem la mateixa estructura però amb el hierarchical cllustering on en compte d'utilitzar el t-SNE per la visualització s'ha utilitzat un dendograma per la seva natruralesa d'agrupar dades com si fos un arbre.</p>
            </div>
        </div>
    </div>

    <!-- Button Container -->
    <div class="button-container horizontal" id="clusteringButtonContainer">
        <!-- Buttons for clustering options will be dynamically created -->
    </div>

    <!-- Content container for images -->
    <div class="container">
        <!-- Image container -->
        <div class="column">
            <img id="loadCurveKmeansImg" width="600px" src="" alt="Displayed Image (Load Curve)">
        </div>
        <div class="column">
            <img id="tsneImage" width="400px" src="" alt="TSNE Visualization">
        </div>
        <div class="column">
            <img id="silhouetteKmeansImage" width="600px" src="" alt="Silhouette Image">
        </div>
    </div>

    <div class="container">
        <!-- Image container -->
        <div class="column">
            <img id="loadCurveHierarchicalImg" width="600px" src="" alt="Displayed Image (Load Curve)">
        </div>
        <div class="column">
            <img id="dendogramImage" width="600px" src="" alt="Dendogram">
        </div>
        <div class="column">
            <img id="silhouetteHierarchicalImage" width="600px" src="" alt="Silhouette Image">
        </div>
    </div>

    <!-- Sliders below images -->
    <div class="slider-container">
        <div class="slider-wrapper">
            <label for="imageSlider">Clusters:</label>
            <input id="imageSlider" type="range" min="1" max="6" value="1">
            <div class="slider-labels" id="sliderLabels"></div>
        </div>
        <div class="slider-wrapper">
            <label for="pcaSlider">PCA:</label>
            <input id="pcaSlider" type="range" min="2" max="5" value="2">
            <div class="slider-labels" id="pcaLabels"></div>
        </div>
    </div>

    <!-- Silhouette Container -->
    <div class="container">
        <div class="column">
            <div class="content-text">
                <p>S'han provat cinc tècniques d'escalat per cada tipus d'algorisme per comprovar els seus propòsits diferents, adaptades a la naturalesa de les dades:</p>
                <ol>
                    <li><strong>MinMaxScaler</strong>: Escala les dades a un rang fix, típicament [0, 1]. Això és útil per assegurar que totes les característiques contribueixen de manera igual al clustering, especialment quan s'utilitzen algorismes basats en distància com el KMeans, els quals són sensibles a la magnitud de les característiques.</li>
                    <li><strong>StandardScaler</strong>: Estandarditza les dades eliminant la mitjana i escalant-les a una variància unitària. Aquest mètode és efectiu quan les dades tenen una distribució similar a una normal, ja que centra les dades i facilita la identificació de clusters equilibrant l'escala de les característiques.</li>
                    <li><strong>RobustScaler</strong>: Escala les característiques basant-se en la mediana i el rang interquartílic, fet que el fa resistent als valors atípics. Això és especialment útil per a conjunts de dades com les corbes diàries de càrrega elèctrica, on els patrons de consum poden incloure anomalies o valors extrems que, d'una altra manera, distorsionarien el clustering.</li>
                    <li><strong>MaxAbsScaler</strong>: Escala les dades dividint-les pel valor absolut màxim de cada característica, mantenint l'escassetat de les dades. Això és útil per a conjunts de dades on les característiques representen proporcions o percentatges, com els valors de càrrega normalitzats.</li>
                    <li><strong>PowerTransformer</strong>: Aplica una transformació exponencial o logarítmica per fer que les dades siguin més similars a una distribució normal, reduint l'asimetria. Això és especialment útil per a dades amb distribucions molt asimètriques.</li>
                </ol>
                <p>Tenint en compte els diferents tipus d'escalat utilitzats, podrem determinar com estan compostes les dades analitzades i quin escalat seria el més adient.</p>
                <h3>Per què disminueix el coeficient de silueta a mesura que augmenten els clusters?</h3>
                <p>El coeficient de silueta mesura com de ben definits i separats estan els clusters, equilibrant la cohesió dins dels clusters amb la separació entre clusters. Quan s'augmenta el nombre de clusters a KMeans (a partir de 3), el coeficient de silueta es veu molt reduït:</p>
                <ul>
                    <li><strong>Sobreajustament dels clusters</strong>: Dividir les dades en més clusters pot provocar un sobreajustament, on els clusters esdevenen massa específics i no capturen agrupacions significatives.</li>
                    <li><strong>Rendiments decreixents</strong>: A partir d’un cert nombre de clusters, afegir-ne més no millora significativament la separació dels punts de dades, fet que provoca una disminució del coeficient de silueta.</li>
                </ul>
                <p>Es va observar com el nombre de clusters continuava disminuint a partir de 7 clusters, per aquest es motiu es va definir el rang de 2 a 7 clusters. De forma similar, tenint en compte que el màxim de dimensions que tenim en el nostre dataset es d'un total de 8, i a partir d'una dimensionalitat de 5, els resultats eren molt similars es va reduir el rang del PCA de 2 a 5.</p>
            </div>
        </div>
        <div class="column">
            <div class="content-text">
                <p>El pic en 3 clusters a les dades de consum elèctric probablement reflecteix una segmentació natural dels patrons diaris de càrrega. Aquest patró es repeteix en els dos models de clustering i en tots els tipus d'escalat, juntament amb el màxim del coeficient de silueta centrat en un nombre de 3 clusters. Més enllà d'això, dividir les dades encara més pot diluir aquests patrons i donar lloc a clusters menys significatius.</p>
            
                <h3>Per què una dimensionalitat baixa de PCA millora el coeficient de silueta?</h3>
                <p>PCA redueix la dimensionalitat de les dades mentre preserva la variància d'aquestes, fet que facilita que els algorismes de clustering es concentrin en els aspectes més informatius de les dades. Per a les corbes de càrrega elèctrica, els components principals capturen variacions significatives en els patrons diaris, com els moments de màxim consum i la distribució general de la càrrega.</p>
                <p>A més, PCA permet una reducció del soroll: excloure components menys rellevants elimina el soroll i les característiques redundants, fent que els clusters siguin més distintius. Això és molt notable amb dimensionalitats altes, on la visualització del t-SNE presenta cada cop més soroll entre els diferents tipus de clusters. En canvi, amb valors baixos, els clusters queden més organitzats facilitant al algorisme K-means un millor agrupament. En el cas del hierarchical clustering la distribució del nombre total punts de dades d'una fulla a una latra es veu bastant afectada en funció de grau de PCA seleccionat.</p>
                <h3>Millors resultats</h3>
                <p>Així doncs els millors resultats els podem basar en el coeficient obtingut en la silueta. Encara que els resultats entre models no han variat per molta diferència, de mitjana l'algorisme K-means ha rendit millor que el hierarchical clustering en aquest coeficient i per tant serà el model utilitzat en posteriors algorismes. En el rànking de millors resultats amb diferents tipus d'escalat tenim:</p>
                <ol>
                    <li><strong>MaxAbsScaling</strong>: PCA 2 i Num. Clusters: 3 (0.46)</li>
                    <li><strong>ZNormScaling (StandardScaling)</strong>: PCA 2 i Num. Clusters: 3 (0.46)</li>
                    <li><strong>MinMaxScaling</strong>: PCA 2 i Num. Clusters: 2 (0.46)</li>
                    <li><strong>PowerTransformer</strong>: PCA 2 i Num. Clusters: 3 (0.44)</li>
                    <li><strong>RobustScaling</strong>: PCA 2 i Num. Clusters: 3 (0.42)</li>
                </ol>
                <p>En casi tots els tipus d'escalats trobem que el nombre de clusters óptim és 3, i com ja s'ha comentat anteriorment la reducció de dimensionalitat (PCA) la mantidrem en 2.</p>
            </div>
        </div>
    </div>

    <!-- Separator line across the screen -->
    <div class="separator"></div>

    <!-- Classification -->
    <div class="header">
        <div class="title">Classification: Day-Ahead Load Curve Probability</div>
    </div>

    <!--Introduction-->
    <div class="container">
        <div class="column">
            <div class="content-text">
                <p>En aquest apartat estarem gestionant diversos conjunts de dades que proporcionen un context important per a l'anàlisi de la carga electrica. Aquests conjunts de dades inclouen dades de <strong>consum</strong>, que detallen l'ús d'electricitat, dades de <strong>temps</strong> amb factors ambientals com la temperatura i la humitat, dades <strong>socioeconòmiques</strong> per entendre la demografia de les regions, i dades de <strong>cadastre</strong> per a informació sobre els edificis, com el nombre d'habitatges i les seves condicions. A més, es fa servir dades de <strong>codi postal</strong> per aportar context espacial a l'anàlisi de patrons regionals.</p>
                <p>Abans d'entrenar els models de classificació necessitem processar les dades, partint de les dades de consum electric del apartat de clustering, netegem i transformem les dades del cadastre i del codi postal, assegurant la consistència dels noms de les columnes i l'alineació espacial, especialment quan associem els edificis als codis postals. Les dades meteorològiques es transformen per ser agregades de manera diària, centrant-nos en factors rellevants com la temperatura ambiental, la humitat i la radiació solar, que podrien influir en els patrons de consum d'electricitat. Després del preprocessament, les dades estan llestes per a l'escalat i el clustering.</p>
                <p>S'ha escollit <strong>RobustScaling</strong> ja que és dels pocs tipus d'escalat que en la fase de clustering ens ha aportat un coeficient de silueta elevat utilitzant un nombre de clusters més grans que 3, i per aquest motiu l'utilitzarem per comprobar alguna correlació amb el nombre de clusters i la capacitat de classificació, els altres dos tipus d'escalat els mantidnrem en 3 clusters. També es realitza <strong>PCA (Principal Component Analysis)</strong> per reduir la dimensionalitat abans del clustering, cosa que ajuda a visualitzar els resultats en un espai 2D.</p>
            </div>
        </div>
        <div class="column">
            <div class="content-text">
                <p>El procés d'escalat és clau per normalitzar les dades abans de l'anàlisi posterior. Partint del apartat de clustering ens centrarem en aquells tipus d'escalat que ens aportat millors resultats, s'apliquen tres tipus d'escalat: <strong>ZNormScaling</strong>, <strong>MaxAbsScaling</strong> i <strong>RobustScaling</strong>, cadascun transformant les dades per tenir una varietat de resultats.</p>
                <p>Finalment, l'anàlisi inclou la classificació i l'evaluació del model. Es fa servir un <strong>Random Forest Classifier</strong> que s'entrena amb les dades agrupades, juntament amb altres característiques derivades dels conjunts de dades combinats, com l'estat socioeconòmic, els patrons meteorològics i la informació del cadastre. El rendiment del model es valora mitjançant mètriques d'exactitud i matrius de confusió, i també es visualitzen les importàncies de les característiques per entendre quines variables contribueixen més a les prediccions del model. A més, s'aplica <strong>t-SNE</strong> per visualitzar com els clústers i les classificacions incorrectes s'alineen, proporcionant informació sobre el procés de classificació. Aquestes visualitzacions, juntament amb l'anàlisi de les importàncies de les característiques, ens permeten entendre millor les relacions entre les dades i les prediccions del model.</p>            
            </div>
        </div>
    </div>

    <div class="container">
        <div class="column">
            <img id="gridSearchResults" width="600px" src="" alt="Grid Search Results">
        </div>
        <div class="column">
            <img id="featureImportances" width="800px" src="" alt="Feature Importances">
        </div>
    </div>

    <!-- Classification Results Section -->
    <div class="button-container horizontal" id="classificationScalingButtonsContainer">
        <!-- Buttons for selecting classification scaling types will be dynamically created -->
    </div>

    <div class="container">
        <div class="column">
            <div class="content-text">
                <p>Per trobar els valors òptims dels hiperparàmetres, s'ha utilitzat un enfocament de <strong>GridSearch</strong>, comprovant diferents nombres d'estimadors i profunditats del model. A més, s'ha aplicat <strong>Cross-Validation</strong> al conjunt de dades de <em>training</em> i <em>testing</em> per identificar el model més adequat dins d'aquest conjunt de dades.</p>
                <p>A la imatge de l'esquerra es poden observar els resultats del <strong>GridSearch</strong> representats en un <em>HeatMap</em>. Les components horitzontals mostren el nombre d'estimadors utilitzats, mentre que les verticals representen la profunditat del model. En tots els tipus d'escalat de dades, es pot observar que a partir d'una profunditat superior a 20 no s'obté cap avantatge significatiu. De manera similar, es veu que amb qualsevol nombre d'estimadors s'obtenen resultats similars. Per tant, per optimitzar el model, es poden utilitzar hiperparàmetres més baixos i, en conseqüència, menys costosos en termes de processament, amb una profunditat de 20 i un nombre d'estimadors de 200.</p>
                <p>En aquest <em>HeatMap</em>, s'ha provat l'escalat <strong>RobustScaling</strong> amb 7 clústers. Si analitzem el coeficient de silueta d'aquest tipus d'escalat, observem que sobresurt respecte als altres. Això ha motivat la seva utilització per comprovar altres dades i identificar tendències que podrien quedar ocultes si sempre s'utilitza el mateix nombre de clústers.</p>                
            </div>
        </div>
        <div class="column">
            <div class="content-text">
                <p>És important conèixer quines característiques ha utilitzat el model de classificació per determinar a quin clúster correspon cada punt de dades. A la imatge de la dreta es pot observar un rànquing de les característiques, ordenades de més importants a menys importants. En els escalats <strong>MaxAbsScaling</strong> i <strong>ZNormScaling</strong>, es veuen tendències molt similars, destacant el dia de la setmana com la característica més rellevant. Segueixen els elements mediambientals, com era d'esperar, amb factors com la temperatura i la humitat de l'aire. Aquestes variables estan fortament relacionades, ja que una major humitat s'associa sovint a dies de pluja o boira, que poden requerir l'encesa de llums o l'ús de la calefacció.</p>
                <p>A més, altres dades socioeconòmiques també juguen un paper clau en aquesta classificació. Entre elles, el nombre d'habitatges, urbanitzacions i la densitat de població esdevenen factors significatius, complementant les característiques mediambientals en la determinació dels clústers.</p>
                <p>Curiosament, a mesura que incrementem el nombre de clústers (com en el cas de l'escalat <strong>RobustScaling</strong>), s'observa que les característiques més importants es concentren en les dades mediambientals, mentre que les socioeconòmiques passen a un segon pla. Això podria ser degut al fet que, en augmentar el nombre de clústers, les dades s'acoten massa, fent que aquelles característiques més influents en un nombre reduït de clústers perdin rellevància en la classificació.</p>
                <p>Un exemple d'això seria la temperatura, que, independentment de les dades socioeconòmiques, manté una forta relació amb el consum d'electricitat. Això es deu al fet que factors com el clima influeixen directament en l'ús d'aparells com la calefacció o l'aire condicionat, fent que aquestes característiques continuïn sent determinants.</p>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="column">
            <img id="confusionMatrix" width="600px" src="" alt="Confusion Matrix">
        </div>
        <div class="column">
            <img id="tsneMisclassifiedPoints" width="800px" src="" alt="t-SNE Misclassified Points">
        </div>
    </div>

    <!-- Classification Results Section -->
    <div class="button-container horizontal" id="classificationMisclassifiedButtonsContainer">
        <!-- Buttons for selecting classification scaling types will be dynamically created -->
    </div>

    <div class="container">
        <div class="column">
            <div class="content-text">
                <p>Tot i haver obtingut bons resultats de precisió en la predicció de quin clúster correspon a un tipus de dada (al voltant del 91% en dades de test i 100% en dades de training), és important analitzar els casos en què aquesta predicció ha fallat. Ens interessa identificar si els errors són deguts al conjunt total de dades, al nombre de clústers o a altres factors que puguem observar. Per aquest motiu, s'ha generat una <strong>Confusion Matrix</strong> per analitzar el total de dades de <em>testing</em> que han estat classificades incorrectament.</p>
                <p>A la diagonal de la <strong>Confusion Matrix</strong> es troben les dades classificades correctament, mentre que les altres caselles mostren els punts de dades que pertanyien a un clúster però han estat assignats a un altre. Inicialment, es volia comprovar si hi havia alguna relació entre el total de dades que pertanyien a un clúster i el nombre d'encerts. Aquesta relació, però, no s'ha confirmat del tot. Encara que en la <strong>Confusion Matrix</strong> pot semblar que alguns punts de dades es concentren en funció del nombre total, l'anàlisi del gràfic de la dreta revela que es tracta d'un altre tipus de relació.</p>
            </div>
        </div>
        <div class="column">
            <div class="content-text">
                <p>En aquesta visualització amb <strong>t-SNE</strong>, s'han combinat les prediccions de dades amb la seva classificació real. Els punts incorrectament classificats s'han marcat amb una "X", la qual cosa ens ha permès identificar les relacions entre els punts classificats correctament i incorrectament.</p>
                <p>S'observa que la distribució dels clústers al conjunt de dades no està del tot ben definida, ja que hi ha diversos punts d'altres clústers que interfereixen en zones on predomina un altre clúster. Aquest fenomen sembla ser la causa principal de la classificació incorrecta. En clústers més organitzats, aquest problema no es presenta. Per tant, podem concloure que aquest índex d'error podria ser degut a una falta de precisió en agrupar les dades, possiblement causada pel soroll present en el conjunt de dades al combinar-les amb altres datasets com les dades socioeconòmiques o medioambientals.</p>
                <p>Evidentment, partint d'aquest mateix problema, en utilitzar 7 clústers amb l'escalat <strong>RobustScaling</strong>, aquest fenomen es veu encara més amplificat. Això provoca una disminució de la capacitat de predicció a mesura que s'afegeixen més clústers i, com a conseqüència, s'incrementa el soroll en el conjunt de dades.</p>
            </div>
        </div>
    </div>

    <!-- Separator line across the screen -->
    <div class="separator"></div>

    <!-- Regression -->
    <div class="header">
        <div class="title">Regression: Electricity Consumption Short-term Forecast</div>
    </div>

    <div class="container">
        <div class="column">
            <div class="content-text">
                <p>En aquest apartat es descriu el procés d'anàlisi i modelatge de dades per a predir el consum elèctric, utilitzant diferents models de regressió. Els conjunts de dades inclouen dades horàries de consum elèctric, condicions meteorològiques (com la temperatura i humitat), dades socioeconòmiques per entendre les característiques demogràfiques i dades cadastrals amb informació sobre els edificis, com ara el nombre d'habitatges i les seves condicions.</p>
                <p>El primer pas és la integració i el preprocessament d'aquestes dades. Les dades de consum s'enriqueixen amb informació meteorològica, socioeconòmica i cadastral, integrant-les amb el codi postal i temps. A més, es generen noves característiques derivades, com el mes i el dia de la setmana, per capturar patrons temporals. Aquest conjunt de dades combinat es transforma en un format adequat per a l'entrenament i l'avaluació de models de regressió.</p>
                <p>Abans de l'entrenament, es defineixen les característiques d'entrada i la variable objectiu. Les columnes categòriques es processen mitjançant codificació <strong>one-hot</strong>, mentre que les columnes numèriques es normalitzen amb l'escalador <strong>StandardScaler</strong> per assegurar que totes les variables tinguin la mateixa escala. Aquesta normalització és crucial per millorar la precisió dels models de regressió.</p>
            </div>            
        </div>
        <div class="column">
            <div class="content-text">
                <p>Per a la modelització, s'exploren diferents algorismes com: <strong>Gradient Boosting Regressor</strong>, <strong>Decision Tree Regressor</strong> i <strong>Random Forest Regressor</strong>. Els hiperparàmetres de cada model es seleccionen mitjançant cerca exhaustiva amb <strong>Cross Validation</strong>, optimitzant mètriques com l'error quadràtic mitjà (RMSE). Es crea un pipeline que combina els passos de preprocessament i modelatge, assegurant que tot el procés sigui consistent i replicable.</p>
                <p>L'avaluació dels models inclou diverses tècniques, com ara la importància de les característiques per comprendre la rellevància de les diferents variables en les prediccions. Es realitzen visualitzacions per interpretar millor els resultats, incloent-hi gràfics de residus, corbes d'aprenentatge i mapes de calor que mostren els resultats de la cerca d'hiperparàmetres. A més, es generen gràfics específics per als errors residuals i per l'impacte de les característiques en els models basats en arbres.</p>
                <p>Finalment, els millors models entrenats es guarden per a ús futur, i es documenten els resultats obtinguts per facilitar la seva interpretació. Aquest enfocament sistemàtic permet comprendre millor els factors que influeixen en el consum elèctric i proporciona eines per fer prediccions més precises en escenaris pràctics com serien els codis postals .</p>          
            </div>
        </div>
    </div>

    <!-- Load curve prediction scroll -->
    <div class="container">
        <div class="column">
            <div class="title">DecisionTree</div>
            <iframe id="pdf1" src="../plots/PostalCodesPredictions/DecisionTree/25001.pdf#page=1" width="600" height="300"></iframe>
        </div>
        <div class="column">
            <div class="title">GradientBoosting</div>
            <iframe id="pdf2" src="../plots/PostalCodesPredictions/GradientBoosting/25001.pdf#page=1" width="600" height="300"></iframe>
        </div>
        <div class="column">
            <div class="title">RandomForest</div>
            <iframe id="pdf3" src="../plots/PostalCodesPredictions/RandomForest/25001.pdf#page=1" width="600" height="300"></iframe>
        </div>
    </div>

    <button onclick="increasePage()">Next Page</button>
    <div>
        <label for="postalCodeSelect">Choose Postal Code:</label>
        <select id="postalCodeSelect" onchange="updatePostalCode()">
            <option value="25001">25001</option>
            <option value="25002">25002</option>
            <option value="25003">25003</option>
            <option value="25004">25004</option>
            <option value="25005">25005</option>
            <option value="25006">25006</option>
            <option value="25007">25007</option>
            <option value="25008">25008</option>
            <option value="25110">25110</option>
            <option value="25111">25111</option>
            <option value="25113">25113</option>
            <option value="25190">25190</option>
            <option value="25191">25191</option>
            <option value="25192">25192</option>
            <option value="25193">25193</option>
        </select>
    </div>

    <div class="container">
        <div class="column">
            <div class="content-text">
                <p>En les tres gràfiques superiors es mostren els resultats de la predicció per a cada tipus de model de regressió. Per a cada model, s'han realitzat prediccions de diferents codis postals, amb un total de 10 prediccions durant un període de 96 hores.</p>
                <p>Aquestes prediccions s'han realitzat en un conjunt de dades específic per analitzar com els models responen davant diferents patrons de càrrega elèctrica. Els resultats obtinguts ens han permès avaluar quins models són més eficaços en condicions concretes.</p>
                <p>A més, s'ha observat que la precisió dels models depèn en gran mesura de la tipologia de la càrrega elèctrica, si segueix un patró previsible o si és més erràtica i caòtica. Els models han estat provats sota diverses condicions per assegurar la seva robustesa.</p>
            </div>            
        </div>
        <div class="column">
            <div class="content-text">
                <p>Analitzant les gràfiques generades, observem que en la majoria de casos tots tres models són capaços d'ajustar-se a la càrrega elèctrica real amb petites variacions en alguns pics. En general, els models ronden millor quan les tendències elèctriques segueixen un patró més específic (per exemple, el codi postal 25001).</p>
                <p>En canvi, amb càrregues elèctriques més caòtiques i variades (com el codi postal 25193), els models de <strong>DecisionTree</strong> i <strong>GradientBoosting</strong> no aconsegueixen ajustar-se completament. Una observació important és que el model de <strong>DecisionTree</strong> tendeix a sobreestimar la càrrega elèctrica, mentre que el model de <strong>GradientBoosting</strong> sovint la subestima.</p>
                <p>El model que ha demostrat millor capacitat d'ajustar-se a la corba elèctrica sense grans complicacions ha estat el <strong>RandomForest</strong>, tot i que els tres models han aportat bons resultats. Això ens suggereix que, tot i que tots els models tenen un rendiment acceptable, el <strong>RandomForest</strong> és el més robust davant diferents tipus de variabilitat en les dades.</p>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="column">
            <div class="title">DecisionTree</div>
            <img width="600px" src="../plots/Regression/DecisionTree/grid_search_heatmap.png" alt="DecisionTree GridSearch">
        </div>
        <div class="column">
            <div class="title">GradientBoosting</div>
            <img width="600px" src="../plots/Regression/GradientBoosting/grid_search_heatmap.png" alt="GradientBoosting GridSearch">
        </div>
        <div class="column">
            <div class="title">RandomForest</div>
            <img width="600px" src="../plots/Regression/RandomForest/grid_search_heatmap.png" alt="RandomForest GridSearch">
        </div>
    </div>

    <div class="container">
        <div class="column">
            <div class="content-text">
                <p>
                    En aquest apartat es discutiran els diferents hiperparàmetres utilitzats en el GridSearch per a cada model de regressió. Els models utilitzats inclouen <strong>DecisionTree</strong>, <strong>GradientBoosting</strong> i <strong>RandomForest</strong>. Per a tots aquests models, s'han realitzat proves amb una gamma d'hiperparàmetres per trobar la millor configuració possible. Tanmateix, com s'explicarà més endavant, els hiperparàmetres que no aportaven millores significatives han estat eliminats per optimitzar els temps de còmput i millorar la comprensió dels resultats.
                </p>
                <p>
                    Els models de regressió intenten establir una relació entre les variables independents (com les característiques d'entrada) i la variable dependent (el resultat que es vol predir). A continuació, es detallen els resultats dels experiments amb cadascun d'aquests models, com també una explicació de la seva naturalesa i capacitats.
                </p>
                <p>
                    Per al model de <strong>DecisionTree</strong>, s'han provat diverses combinacions de profunditat, variant entre 5 i 60. Tot i que en la gràfica final només es mostren els valors de profunditat entre 20 i 60, inicialment es van provar combinacions més àmplies per explorar millor el rang. A mesura que es reduïa el nombre d'hiperparàmetres per a la visualització, es va observar que un mínim de mostres per fulla de 15 i una profunditat màxima de 30 o 60 resultaven ser les millors opcions. Els valors intermitjos de profunditat van empitjorar la capacitat de regressió del model.
                </p>
                <p>
                    Un <strong>DecisionTree</strong> és un model de regressió basat en una estructura arbòria on cada node intern representa una condició sobre una variable, i cada branca representa el resultat de l'avaluació d'aquesta condició. El model és capaç de modelar relacions no lineals entre les característiques d'entrada i la variable objectiu. Tot i això, tendeix a sobreajustar-se als valors específics de les dades d'entrenament si no es prenen mesures com la limitació de la profunditat o la reducció de mostres per fulla.
                </p>
                <p>
                    En el cas del model de <strong>GradientBoosting</strong>, es van utilitzar dos hiperparàmetres principals: el ratio d'aprenentatge i la profunditat màxima. En contrast amb els models basats en arbre, la profunditat no va ser un factor significatiu, i els millors resultats es van obtenir amb un ratio d'aprenentatge més alt (0.2) i un nivell de profunditat baix (10). Tot i que es va provar amb més ratios com 0.01, per tal de reduir els temps de còmput aquest es va limitar als paràmetres que es mostren en la gràfica. També es va provar amb un mínim de mostres entre 100 i 300, però això no va millorar els resultats de manera notable, pel que s'hann eliminat per aquesta visualització.
                </p>
                
            </div>
        </div>
        <div class="column">
            <div class="content-text">
                <p>
                    El <strong>GradientBoosting</strong> és un model de regressió basat en el principi de l'augment de gradients. Funciona mitjançant la combinació de múltiples models febles (normalment arbres de decisió) per crear un model més potent. Cada arbre posterior corregeix els errors dels arbres anteriors mitjançant un procés d'optimització iterativa. Aquest model és molt potent per capturar relacions no lineals complexes, però pot ser sensible a sorolls en les dades si no es controla correctament el ritme d'aprenentatge.
                </p>
                <p>
                    Finalment, el model de <strong>RandomForest</strong> va seguir un patró més lineal en funció de la profunditat i el nombre d'estimadors. Els millors resultats es van obtenir amb una profunditat de 30 i 200 estimadors. Malauradament, no es van poder provar combinacions més àmplies d'hiperparàmetres per limitacions de memòria RAM, ja que el model requereix una gran quantitat de recursos (Després de 12 hores processant va passar-se dels 32GB de RAM més d'un cop petant l'ordinador). Tot i així, el RandomForest va ser el model amb millor rendiment de predicció comparat amb els altres models.
                </p>
                <p>
                    El <strong>RandomForest</strong> és un model basat en l'ensamblatge d'arbres de decisió. Utilitza múltiples arbres que es construeixen de manera independent a partir de submostres aleatòries de les dades d'entrenament. Els arbres es combinen per obtenir una predicció final mitjançant votació (en classificació) o mitjana (en regressió). Aquest model és robust davant el sobreajustament i, a més, pot gestionar molt bé grans quantitats de dades i característiques.
                </p>
                <p>
                    En resum, els hiperparàmetres utilitzats van jugar un paper crucial en l'ajust de cada model. Per al DecisionTree, la profunditat i les mostres per fulla van ser determinants, mentre que en el GradientBoosting, el ratio d'aprenentatge va influir més en els resultats. El RandomForest va ser el millor en termes de rendiment predicció, tot i les limitacions de memòria.
                </p>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="column">
            <div class="title">DecisionTree</div>
            <img width="600px" src="../plots/Regression/DecisionTree/learning_curve.png" alt="DecisionTree learning_curve">
        </div>
        <div class="column">
            <div class="title">GradientBoosting</div>
            <img width="600px" src="../plots/Regression/GradientBoosting/learning_curve.png" alt="GradientBoosting learning_curve">
        </div>
        <div class="column">
            <div class="title">RandomForest</div>
            <img width="600px" src="../plots/Regression/RandomForest/learning_curve.png" alt="RandomForest learning_curve">
        </div>
    </div>

    <div class="container">
        <div class="column">
            <div class="content-text">
                <p><strong>Model Decision Tree:</strong></p>
                <p>L'RMSE d'entrenament augmenta i l'RMSE de validació disminueix. Aquest patró pot indicar que el model d'arbre de decisions està regularitzant-se o es torna més senzill a mesura que es veu exposat a més dades. El model podria estar limitant la seva complexitat (per exemple, restringint la profunditat de l'arbre o el nombre de divisions) per evitar el sobreajustament. La disminució de l'RMSE de validació indica que el model millora en la seva capacitat de generalitzar a dades no vistes. Això suggereix que el model podria estar beneficiant-se de la regularització, millorant la seva capacitat de generalització.</p>
        
                <p><strong>Model de Gradient Boosting:</strong></p>
                <p>En aquest cas, l'RMSE d'entrenament augmenta i l'RMSE de validació disminueix, un patró similar al de l'Arbre de Decisions. Aquest comportament podria indicar que el model està regularitzant-se més. El Gradient Boosting funciona ajustant-se iterativament a arbres de decisions i, amb més dades, podria estar aprenent una millor generalització, amb arbres més petits o menys rondes de reforç per evitar el sobreajustament. La disminució de l'RMSE de validació suggereix que el model està millorant la seva capacitat de generalitzar a dades noves.</p>
        
                <p><strong>Model de Random Forest:</strong></p>
                <p>En aquest cas, l'RMSE d'entrenament es manté constant i l'RMSE de validació disminueix. Això suggereix que el model de Random Forest manté un rendiment constant en el conjunt d'entrenament, la qual cosa indica que no s'està sobreajustant ni infraajustant significativament. Els Random Forests tenen una bona capacitat per equilibrar el biaix i la variància, la qual cosa els fa robustos davant canvis en la mida del conjunt d'entrenament. La disminució de l'RMSE de validació mostra que, a mesura que s'introdueixen més dades, el model millora la seva capacitat de generalitzar.</p>    
            </div>
        </div>
        <div class="column">
            <div class="content-text">
                <p><strong>Resum de tots els models:</strong></p>
                <ol>
                    <li><strong>Decision Tree:</strong> L'augment de l'RMSE d'entrenament i la disminució de l'RMSE de validació suggereixen que el model s'està simplificant o regularitzant a mesura que es proporcionen més dades, millorant la seva capacitat de generalitzar a dades no vistes. Això és un signe positiu que el model evita el sobreajustament.</li>
                    <li><strong>Gradient Boosting:</strong> Igual que l'Arbre de Decisions, l'augment de l'RMSE d'entrenament i la disminució de l'RMSE de validació indiquen que la regularització (a través del procés de reforç) està millorant la generalització. El model podria estar sacrificant rendiment en l'entrenament per millorar el rendiment en validació, la qual cosa és un bon indicador d'aprenentatge robust.</li>
                    <li><strong>Random Forest:</strong> L'RMSE d'entrenament constant i la disminució de l'RMSE de validació suggereixen que el model manté la una bona predicció mentre millora la seva capacitat de generalitzar a mesura que es proporciona més dades. El model es manté consistent tant en l'entrenament com en la validació.</li>
                </ol>
                <p><strong>Conclusió general:</strong></p>
                <p>L'augment de l'RMSE d'entrenament (per a l'Arbre de Decisions i Gradient Boosting) mentre que l'RMSE de validació disminueix és un indicador que els models estan regularitzant-se i aprenent a generalitzar millor a mesura que veuen més dades. La manteniment de l'RMSE d'entrenament amb la disminució de l'RMSE de validació (per a Random Forest) suggereix que el model ja està ben regularitzat i continua millorant la seva capacitat de generalitzar. En tots els casos, la disminució de l'RMSE de validació és un signe positiu, ja que mostra que els models estan millorant el seu rendiment en dades no vistes, que és l'objectiu final. Aquest comportament és típic quan els models estan reduint el sobreajustament a mesura que es proporciona més informació, i és un bon signe de millora en les capacitats de generalització. En general podem afirmar que el Random Forest ha aconseguit uns millors resultats respecte la resta de models.</p>    
            </div>
        </div>
    </div>

    <div class="container">
        <div class="column">
            <div class="title">DecisionTree</div>
            <img width="600px" src="../plots/Regression/DecisionTree/residual_plot.png" alt="DecisionTree residual_plot">
        </div>
        <div class="column">
            <div class="title">GradientBoosting</div>
            <img width="600px" src="../plots/Regression/GradientBoosting/residual_plot.png" alt="GradientBoosting residual_plot">
        </div>
        <div class="column">
            <div class="title">RandomForest</div>
            <img width="600px" src="../plots/Regression/RandomForest/residual_plot.png" alt="RandomForest residual_plot">
        </div>
    </div>

    <div class="container">
        <div class="column">
            <div class="content-text">
                <p>Una bona forma de mesurar la precisió del model és mitjançant la ResidualPlot, que mostra la diferència entre els valors reals i els predits (els residus). Quan els punts estan més a prop de l’eix horitzontal, el model té una millor capacitat predictiva. Però a mesura que l’horitzó de predicció s’allarga, els residus tendiran a augmentar, la qual cosa indica que el model es desvia més dels valors reals a mesura que s’allunya del moment actual.</p>
            </div>
        </div>
        <div class="column">
            <div class="content-text">
                <p>En les prediccions a llarg termini, és comú que els models de sèries temporals experimentin un augment de la incertesa, ja que els patrons es basen en extrapolacions i petits errors poden acumular-se. A mesura que augmenta el nombre de prediccions, els errors també poden créixer, ja que el model s’ha d’enfrontar a la dificultat de predir patrons futurs basats en dades passades. Aquesta incertesa s'intensifica a mesura que el model intenta predir a horitzons temporals més llargs.</p>
                <p>Observem com el model amb millors resultats és el RandomForest encara que com a la resta de models a mesura que augmentem els valors predits, cada vegada s'allunyen més dels valors reals.</p>
            </div>
        </div>
    </div>    

    <div class="container">
        <div class="column">
            <div class="title">DecisionTree</div>
            <img width="600px" src="../plots/Regression/DecisionTree/permutation_importances.png" alt="DecisionTree permutation_importances">
        </div>
        <div class="column">
            <div class="title">GradientBoosting</div>
            <img width="600px" src="../plots/Regression/GradientBoosting/permutation_importances.png" alt="GradientBoosting permutation_importances">
        </div>
        <div class="column">
            <div class="title">RandomForest</div>
            <img width="600px" src="../plots/Regression/RandomForest/permutation_importances.png" alt="RandomForest permutation_importances">
        </div>
    </div>

    <div class="container">
        <div class="column">
            <div class="content-text">
                <p>En aquest apartat es mostren les gràfiques de la importància de les característiques utilitzades pels diferents models. Es tindrien que haver escalat de forma logarítmica per facilitar les visualitzacions, però per evitar tenir que estar un dia sencer reentrenant els models s'han mantingut així.</p>
                <p>En tots tres es pot observar com els paràmetres més influents s'han centrat en el nombre de contractes inclosos en el consum, la temperatura i el nombre d'arbres, entre altres. Com és d'esperar, el nombre de contractes associats al consum permet als models identificar els patrons necessaris per predir el consum elèctric.</p>
                <p>Curiosament, el model de Decision Tree és l'únic que s'ha centrat en el nombre de cases amb bastanta diferència respecte a la resta de característiques. També cal recalcar com en els models Gradient Boosting i Random Forest ens trobem amb característiques amb importància negativa.</p>
                <p>Que una característica esdevingui negativa no implica necessàriament que sigui dolenta o perjudicial, sinó que en aquest context del dataset no és beneficiosa. És possible que trenqui relacions o que simplement no ajudi al model en concret. Per exemple, en el Decision Tree no ens apareixen característiques amb importància negativa.</p>
            </div>
        </div>
        <div class="column">
            <div class="content-text">
                <p>Conèixer quines característiques són beneficioses per als models és crucial, ja que ens permet centrar els esforços en dades rellevants, eliminant característiques que podrien confondre el model o no aportar valor. Això ajuda a millorar l'eficiència computacional i pot augmentar la precisió del model.</p>
                <p>Basats en aquests resultats, els pròxims passos per optimitzar els models podrien incloure:</p>
                <ul>
                    <li>Experimentar amb tècniques de selecció de característiques, com ara l'eliminació recursiva de característiques (RFE) o models de regularització com Lasso.</li>
                    <li>Reentrenar els models amb subsets de dades seleccionades per confirmar l'impacte de cada característica en el rendiment global.</li>
                </ul>
                <p>Es va intentar realitzar l'eliminació recursiva de característiques (RFE) amb el model RandomForest pero resultava massa intensiva i requeria massa hores de cómput. Per aquest motiu es va probar directament utilitzar un subset amb les característiques més importants.</p>
            </div>
        </div>
    </div>
    
    <script>
        const clusteringScalingOptions = {
            "MaxAbsScaling": "MaxAbsScaling",
            "MinMaxScaling": "MinMaxScaling",
            "RobustScaling": "RobustScaling",
            "ZNormScaling": "ZNormScaling",
            "PowerTransformerScaling": "PowerTransformerScaling"
        };
    
        const classificationScalingOptions = {
            "MaxAbsScaling": "MaxAbsScaling",
            "ZNormScaling": "ZNormScaling",
            "RobustScaling": "RobustScaling"
        };
    
        const clusteringButtonContainer = document.getElementById("clusteringButtonContainer");
        const classificationScalingButtonsContainer = document.getElementById("classificationScalingButtonsContainer");
        const classificationMisclassifiedButtonsContainer = document.getElementById("classificationMisclassifiedButtonsContainer");
        const imageSlider = document.getElementById("imageSlider");
        const pcaSlider = document.getElementById("pcaSlider");

        const loadCurveKmeansImg = document.getElementById("loadCurveKmeansImg");
        const tsneImage = document.getElementById("tsneImage");
        const loadCurveHierarchicalImg = document.getElementById("loadCurveHierarchicalImg");
        const dendogramImage = document.getElementById("dendogramImage");

        const silhouetteKmeansImage = document.getElementById("silhouetteKmeansImage");
        const silhouetteHierarchicalImage = document.getElementById("silhouetteHierarchicalImage");

        const gridSearchResults = document.getElementById("gridSearchResults");
        const featureImportances = document.getElementById("featureImportances");

        const confusionMatrix = document.getElementById("confusionMatrix");
        const tsneMisclassifiedPoints = document.getElementById("tsneMisclassifiedPoints");
    
        let currentClusteringFolder = Object.keys(clusteringScalingOptions)[0];
        let currentClassificationType = Object.keys(classificationScalingOptions)[0];
        let currentImageIndex = 0;
        let currentPCA = 2; // Default to PCA level 2

        let currentPage = 1;  // Initial page
        let selectedPostalCode = "25001"; // Default postal code

        // Sync all iframes when the page changes
        function syncIframes() {
            const pageParam = `#page=${currentPage}`;

            document.getElementById("pdf1").src = `../plots/PostalCodesPredictions/DecisionTree/${selectedPostalCode}.pdf${pageParam}`;
            document.getElementById("pdf2").src = `../plots/PostalCodesPredictions/GradientBoosting/${selectedPostalCode}.pdf${pageParam}`;
            document.getElementById("pdf3").src = `../plots/PostalCodesPredictions/RandomForest/${selectedPostalCode}.pdf${pageParam}`;
        }

        // Increase page number, wrap around using modulus 10
        function increasePage() {
            currentPage = (currentPage % 10) + 1; // Page number increases, modulus 10, wraps to 1 after 10
            syncIframes(); // Sync all iframes
        }

        // Function to update the postal code based on the select box
        function updatePostalCode() {
            selectedPostalCode = document.getElementById("postalCodeSelect").value;
            syncIframes();
        }
    
        // Function to create a button
        function createButton(text, action) {
            const button = document.createElement("button");
            button.textContent = text;
            button.onclick = action;
            button.classList.add('button');
            return button;
        }
    
        // Function to add modular buttons to a container
        function addButtonsToContainer(container, options, action) {
            Object.keys(options).forEach(option => {
                const button = createButton(option, () => {
                    action(option);
                    setSelectedButton(button, container);
                });
                container.appendChild(button);
            });
        }
    
        // Function to handle the button selection styling
        function setSelectedButton(selectedButton, container) {
            container.querySelectorAll('button').forEach(button => button.classList.remove('selected'));
            selectedButton.classList.add('selected');
        }
    
        // Create and add modular clustering scaling buttons dynamically
        addButtonsToContainer(clusteringButtonContainer, clusteringScalingOptions, (folder) => {
            currentClusteringFolder = folder;
            updateClusteringImage();
        });
    
        // Create and add modular classification scaling buttons dynamically
        addButtonsToContainer(classificationScalingButtonsContainer, classificationScalingOptions, (scalingType) => {
            // Update confusion matrix based on selected scaling type
            updateClassificationTrainingImage(scalingType);
        });

        // Create and add modular classification scaling buttons dynamically
        addButtonsToContainer(classificationMisclassifiedButtonsContainer, classificationScalingOptions, (scalingType) => {
            // Update confusion matrix based on selected scaling type
            updateClassificationMissclassifiedImage(scalingType);
        });
    
        // Function to update the clustering image based on current selected settings
        function updateClusteringImage() {
            const currentCluster = parseInt(imageSlider.value) + 1; // Adjust for the 0-indexed slider
            const loadCurveKmeansPath = `../plots/kmeans/${currentClusteringFolder}/pca_${currentPCA}/load_curves_${currentCluster}.png`;
            const tsnePath = `../plots/kmeans/${currentClusteringFolder}/pca_${currentPCA}/tsne_${currentCluster}.png`;

            const loadCurveHierarchicalPath = `../plots/hierarchical/${currentClusteringFolder}/pca_${currentPCA}/load_curves_${currentCluster}.png`;
            const dendogramPath = `../plots/hierarchical/${currentClusteringFolder}/pca_${currentPCA}/dendrogram_${currentCluster}.png`;

            const silhouetteKmeansPath = `../plots/kmeans/${currentClusteringFolder}/pca_${currentPCA}/silhouette.png`;
            const silhouetteHierarchicalPath = `../plots/hierarchical/${currentClusteringFolder}/pca_${currentPCA}/silhouette.png`;
    
            loadCurveKmeansImg.src = loadCurveKmeansPath;
            tsneImage.src = tsnePath;

            loadCurveHierarchicalImg.src = loadCurveHierarchicalPath;
            dendogramImage.src = dendogramPath;

            silhouetteKmeansImage.src = silhouetteKmeansPath;
            silhouetteHierarchicalImage.src = silhouetteHierarchicalPath;
        }
    
        // Function to update the confusion matrix image based on scaling type
        function updateClassificationTrainingImage(scalingType) {
            gridSearchResults.src = `../plots/RandomForestClassifier/${scalingType}/grid_search_results.png`;
            featureImportances.src = `../plots/RandomForestClassifier/${scalingType}/feature_importances.png`;
        }

        function updateClassificationMissclassifiedImage(scalingType) {
            confusionMatrix.src = `../plots/RandomForestClassifier/${scalingType}/confusion_matrix.png`;
            tsneMisclassifiedPoints.src = `../plots/RandomForestClassifier/${scalingType}/tsne_misclassified_points.png`;
        }
    
        // Initialize with the default clustering option
        updateClusteringImage();
        updateClassificationTrainingImage("MaxAbsScaling");
        updateClassificationMissclassifiedImage("MaxAbsScaling");
    
        // Add event listener to the imageSlider to update the images when it changes
        imageSlider.addEventListener('input', function() {
            updateClusteringImage();
        });
    
        // Add event listener to the pcaSlider to update the PCA images when it changes
        pcaSlider.addEventListener('input', function() {
            currentPCA = parseInt(pcaSlider.value); // Update PCA value from slider
            updateClusteringImage(); // Re-render images based on new PCA
        });
    </script>
</body>
</html>